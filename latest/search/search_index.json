{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NiceTrace","text":"<p>NiceTrace is a Python module for user-friendly structured tracing and elegant display of resulting traces.  Traces are stored as plain JSON files. NiceTrace support exploring traces of running process.  While designed for generic usage, it's particularly well-suited for tracing experiments with Large Language Models (LLMs).</p> <p> </p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Here's how to create a simple trace and write it to a JSON file:</p> <pre><code>from nicetrace import trace, FileWriter\n\nwith FileWriter(\"traces/my_trace.json\"):\n    with trace(\"Root node\"):\n        with trace(\"Child node\", inputs={\"x\": 10, \"y\": 20}) as node:\n            node.add_output(\"\", \"Hello world!\")\n</code></pre> <p>To start a traceview server over the <code>traces</code> directory:</p> <pre><code>python3 -m nicetrace.server traces\n</code></pre> <p>Then, open your web browser and navigate to http://localhost:4090 to view your traces.</p> <p> </p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#for-tracing-only","title":"For tracing only","text":"<pre><code>$ pip install nicetrace\n</code></pre>"},{"location":"install/#for-tracing-displaying-traces","title":"For tracing &amp; displaying traces","text":"<pre><code>$ pip install nicetrace[server]\n</code></pre>"},{"location":"integrations/","title":"Integrations","text":""},{"location":"integrations/#integration-with-langchain","title":"Integration with LangChain:","text":"<p>NiceTrace provide an integration with LangChain that automatically logs all invodes of a model.</p> <pre><code>from nicetrace import trace\nfrom nicetrace.ext.langchain import Tracer\n\ntracer = Tracer()\n\n# # Create NiceTrace Tracer for LangChain &amp; Register the tracer within the model\nmodel = langchain_openai.chat_models.ChatOpenAI(\n    model=\"gpt-4o\", callbacks=[Tracer()]),\n\nwith trace(\"My experiment\"):\n    # Call the model. The call is automatically traced under the \"My experiment\" node.\n    model.invoke(\"How are you?\")\n</code></pre> <p></p>"},{"location":"serialization/","title":"Serialization to JSON","text":"<p><code>TracingNode</code> can be serialized into JSON via [to_dict] method:</p> <pre><code>from nicetrace import trace\n\nwith trace(\"my node\", inputs={\"x\": 42}) as node:\n    node.add_outputs(\"y\", \"my_result\")\n</code></pre> <p>Calling <code>node.to_dict()</code> returns:</p> <pre><code>{\n  \"name\": \"my node\",\n  \"uid\": \"li7znrGkQr\",\n  \"entries\": [\n    {\n      \"kind\": \"input\",\n      \"value\": 42,\n      \"name\": \"x\"\n    },\n    {\n      \"kind\": \"output\",\n      \"value\": \"my_result\",\n      \"name\": \"y\"\n    }\n  ],\n  \"start_time\": \"2024-07-08T16:26:48.619336\",\n  \"end_time\": \"2024-07-08T16:26:48.619346\",\n  \"version\": \"4\"\n}\n</code></pre> <p>When inputs or a result are not directly serializable into JSON options are provided:</p>"},{"location":"serialization/#serialization-of-dataclasses","title":"Serialization of dataclasses","text":"<p>Dataclasses are serialized as <code>dict</code>:</p> <pre><code>from dataclasses import dataclass\nfrom nicetrace import trace, with_trace\n\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n\n\n@with_trace\ndef say_hi(person):\n    return f\"Hi {person.name}!\"\n\n\nwith trace(\"root\") as c:\n    person = Person(\"Alice\", 21)\n    say_hi(person)\n</code></pre> <p>creates the following JSON description of the node:</p> <pre><code>{\n  \"name\": \"root\",\n  \"uid\": \"KhwWyfyqGX\",\n  \"children\": [\n    {\n      \"name\": \"say_hi\",\n      \"uid\": \"3cFmee7Oq7\",\n      \"kind\": \"call\",\n      \"entries\": [\n        {\n          \"kind\": \"input\",\n          \"value\": {\n            \"name\": \"Alice\",      # &lt;&lt;&lt;&lt;&lt;&lt;&lt;\n            \"age\": 21,            # &lt;&lt;&lt;&lt;&lt;&lt;&lt;\n            \"_type\": \"Person\"     # &lt;&lt;&lt;&lt;&lt;&lt;&lt;\n          },\n          \"name\": \"person\"\n        },\n        {\n          \"kind\": \"output\",\n          \"value\": \"Hi Alice!\"\n        }\n      ],\n      \"start_time\": \"2024-07-08T16:28:44.392553\",\n      \"end_time\": \"2024-07-08T16:28:44.392573\"\n    }\n  ],\n  \"start_time\": \"2024-07-08T16:28:44.392522\",\n  \"end_time\": \"2024-07-08T16:28:44.392577\",\n  \"version\": \"4\"\n}\n</code></pre>"},{"location":"serialization/#method-__trace_to_node__","title":"Method <code>__trace_to_node__</code>","text":"<p>A user type may define method <code>__trace_to_node__</code> to provide a custom serializer.</p> <pre><code>class Person:\n    name: str\n    age: int\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __trace_to_node__(self):\n        return {\"name\": self.name, \"age\": self.age}\n\nperson = Person(\"Peter\", 24)\n</code></pre> <p>When <code>person</code> is serialized, the following dictionary is produced:</p> <pre><code>{\n    \"name\": \"Peter\",\n    \"age\": 24,\n    \"_type\": \"Person\"\n}\n</code></pre>"},{"location":"serialization/#registration-of-serializer","title":"Registration of serializer","text":"<p>Sometimes we do not or we cannot modify a class. Registration a serializer for a given type is there for this purpose.</p> <pre><code>from nicetrace import register_custom_serializer\n\n\nclass MyClass:\n    def __init__(self, x):\n        self.x = x\n\n\ndef myclass_serializer(m: MyClass):\n    return {\"x\": m.x}\n\n\nregister_custom_serializer(MyClass, myclass_serializer)\n</code></pre>"},{"location":"serialization/#fallback","title":"Fallback","text":"<p>When no mechanism above is used then only name of the type and object <code>id</code> is serialized.</p> <p>E.g.:</p> <pre><code>{\n    \"_type\": \"Person\",\n    \"id\": 140263930622832\n}\n</code></pre>"},{"location":"tracing/","title":"Tracing","text":""},{"location":"tracing/#trace-function","title":"<code>trace</code> function","text":"<p><code>trace()</code> function is a main function that creates a tracing context manager.</p> <pre><code>from nicetrace import trace\n\nwith trace(\"my node\", inputs={\"x\": 42}) as c:\n    y = do_a_computation(x=42)\n    c.set_output(\"y\", y)\n</code></pre>"},{"location":"tracing/#nested-tracing","title":"Nested tracing","text":"<p><code>trace</code> can be nested to construct a hierarchy reflecting the structure of a complex computation:</p> <pre><code>with trace(\"root\") as root:\n    with trace(\"child-1\"):\n       with trace(\"child-1-1\"):\n           pass\n       with trace(\"child-1-2\"):\n           pass\n    with trace(\"child-2\"):\n       pass\n</code></pre> <p>If this tracing nodes are visualized you obtain the following picture:</p> <p></p>"},{"location":"tracing/#tracingnode-states","title":"TracingNode states","text":"<p>Throughout its lifetime, a TracingNode traverses several states:</p> <ul> <li>Open - Running TracingNode</li> <li>Finished - Successfully finished TracingNode</li> <li>Error - Unsuccessfully finished TracingNode</li> </ul> <pre><code>with trace(\"my node\"):\n    # 'node' in OPEN state\n    compute_something()\n# 'node' in FINISHED state\n</code></pre> <p>When an unhandled exception passes through a ContentNode boundary, it sets the node to the ERROR state. Example:</p> <pre><code>with trace(\"my node\"):\n    raise Exception(\"Something is wrong\")\n# TracingNode in ERROR state\n</code></pre> <p>Alternatively, the <code>.set_error(error)</code> method can be called on a node to explicitly set the node to the ERROR state.</p>"},{"location":"tracing/#inputs-and-results","title":"Inputs and Results","text":"<p>Nodes may have one or more named inputs and at most one result</p> <pre><code>from nicetrace import trace\n\nwith trace(\"my node\", inputs={\"x\": 42}) as node:  # Set inputs when tracing is created\n    node.add_inputs({\"y\": 123, \"z\": 321})         # Add inputs dynamically\n    node.add_output(\"my_result\", \"result_value\")  # Set result explicitly\n</code></pre> <p>Names of the inputs/outputs have to be strings.</p>"},{"location":"tracing/#enhancing-functions-with-with_tracing","title":"Enhancing Functions with <code>with_tracing</code>","text":"<p>A function can be annotated with <code>with_tracing</code> decorator. It automatically creates a new <code>TracingNode</code> that captures inputs and the result when the function is called.</p> <pre><code>from nicetrace import with_trace\n\n\n@with_trace\ndef my_computation(x):\n    ...\n</code></pre>"},{"location":"tracing/#instant-events","title":"Instant events","text":"<p>An event is an instant TracingNode with immediate result and no child nodes.</p> <pre><code>with trace(\"root\") as node:\n    node.add_instant(\"Message to Alice\", kind=\"message\", inputs={\"text\": \"Hi, Alice!\"})\n</code></pre>"},{"location":"tracing/#attaching-meta-information","title":"Attaching Meta information","text":"<p>A meta information can be attached to any <code>TracingNode</code> about visualization of a tracing node. Metadata is defined as follows:</p> <pre><code>@dataclass\nclass Metadata:\n    icon: str | None = None\n    color: str | None = None\n    tags: list[Tag] | None = None\n    counters: dict[str, int] | None = None\n    collapse: str | None = None\n    custom: Any = None\n</code></pre> <p>And it is used as follows:</p> <pre><code>from nicetrace import trace, Metadata\n\nwith trace(\"root\", meta=Metadata(icon=\"eye\", color=\"green\")) as node:\n    pass\n</code></pre> <p>Meaning of the fields are as follows:</p> <ul> <li><code>icon</code>: icon of the node, currently supported values: \"eye\", \"person\", and \"query\". Feel free to open an GitHub if you need additional icons.</li> <li><code>colors</code>: HTML color of a given node.</li> <li><code>tags</code>: Tags -- not visualized in the current version</li> <li><code>counters</code>: An integer values assigned to the node. Parent nodes automatically sums its children counters.</li> <li><code>collapse</code>: If at least two nodes with the same non-<code>None</code> collapse value immediately follows, then they will be collaped under a single node in the visualized tree.               Use the plular form in the string in <code>collapse</code> as it will be used with the number of collapsed items. It is designed to hide some repeated less important events.</li> <li><code>custom</code>: Uninterpreted value for user's need.</li> </ul>"},{"location":"view/","title":"Storing & View","text":"<p>For storing a traces you may use <code>FileWriter</code> and <code>DirWriter</code>.  They both stores traces in JSON format. The both saves traces when they are still running so you can observe also running process.</p>"},{"location":"view/#filewriter","title":"FileWriter","text":"<p><code>FileWriter</code> stores trace into a single file.</p> <pre><code>from nicetrace import trace, FileWriter\n\nwith FileWriter(\"traces/my_trace.json\"):\n\n    # Stores the root node and its children into 'my_trace.json'\n    with trace(\"Root node\"):\n        with trace(\"Child node\"):\n            pass\n</code></pre> <p>If more root nodes are created, then <code>FileWriter</code> overrides the previous content.</p> <pre><code>with FileWriter(\"traces/my_trace.json\"):\n\n    # Stores a root node in my_trace.json\n    with trace(\"Root node\"):\n        pass\n\n    # Overwrite my_trace.json with a new root node\n    with trace(\"Root node\"):\n        pass\n</code></pre>"},{"location":"view/#dirwriter","title":"DirWriter","text":"<p><code>FileWriter</code> stores traces into JSON into a given directory. Traces are stored under name <code>trace-&lt;UID&gt;.json</code>. </p> <pre><code>from nicetrace import trace, DirWriter\n\nwith DirWriter(\"traces\"):\n\n    # Stores the node and its child in file trace f\"trace-{root1.uid}.json\"\n    with trace(\"Root node\") as root1:\n        with trace(\"Child node\"):\n            pass\n\n    # Stores the node and its child in file trace f\"trace-{root2.uid}.json\"\n    with trace(\"Root node\") as root2:\n        pass\n</code></pre>"},{"location":"view/#running-a-live-trace-view-over-a-directory","title":"Running a live trace view over a directory","text":"<p>If you install NiceTrace with feature <code>server</code> (<code>pip install nicetrace[server]</code>) then you can run a HTTP server over a directory. It does not matter if trace files were created via <code>FileWriter</code> or <code>DirWriter</code>.</p> <pre><code>python3 -m nicetrace.server &lt;DIRECTORY_WITH_TRACES&gt;\n</code></pre> <p>Then, open your web browser and navigate to http://localhost:4090 to view your traces.</p>"},{"location":"view/#saving-a-trace-as-static-html-file","title":"Saving a trace as static HTML file.","text":"<pre><code>from nicetrace import trace, write_html\n\nwith trace(\"Root node\") as node:\n    with trace(\"Child 1\"):\n        pass\n\nwrite_html(node, \"out.html\")\n</code></pre> <p>It creates a stand-alone HTML file that captures an immediate state of the trace. The content will not be automatically updated if trace is changed.</p>"}]}